import "./chunk-N6KKQAAQ.js";
import "./chunk-YYZQZSN5.js";
import {
  action,
  add_locations,
  append_styles,
  beforeUpdate,
  bind_prop,
  bind_this,
  bind_value,
  bubble_event,
  check_target,
  cleanup_styles,
  createEventDispatcher,
  each,
  hmr,
  if_block,
  index,
  init,
  legacy_api,
  onDestroy,
  onMount,
  prop,
  remove_input_defaults,
  sanitize_slots,
  set_attribute,
  set_attributes,
  set_class,
  set_style,
  set_value,
  slot
} from "./chunk-Z2MUAD7E.js";
import "./chunk-VF3DN2VW.js";
import "./chunk-WOTSTHLU.js";
import {
  append,
  comment,
  ns_template,
  preventDefault,
  set_text,
  stopPropagation,
  template,
  text
} from "./chunk-UQRUOQQH.js";
import {
  $window,
  FILENAME,
  HMR,
  child,
  deep_read_state,
  derived_safe_equal,
  effect,
  event,
  first_child,
  get,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mutable_source,
  mutate,
  pop,
  push,
  reset,
  set,
  sibling,
  strict_equals,
  template_effect,
  tick
} from "./chunk-VBINPFYW.js";
import "./chunk-55T6SK4B.js";
import "./chunk-3LUZOQLA.js";
import "./chunk-2OJJ7JW3.js";
import "./chunk-NNIHVWYK.js";

// node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/.pnpm/@floating-ui+core@1.7.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

// node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/.pnpm/@floating-ui+dom@1.7.0/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root5 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root5.clientWidth - (left + width));
    const insetBottom = floor(root5.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root5.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/.pnpm/svelte-floating-ui@1.5.8/node_modules/svelte-floating-ui/index.js
function createFloatingActions(initOptions) {
  let referenceElement;
  let floatingElement;
  const defaultOptions = {
    autoUpdate: true
  };
  let options = initOptions;
  const getOptions = (mixin) => {
    return { ...defaultOptions, ...initOptions || {}, ...mixin || {} };
  };
  const updatePosition = (updateOptions) => {
    if (referenceElement && floatingElement) {
      options = getOptions(updateOptions);
      computePosition2(referenceElement, floatingElement, options).then((v) => {
        Object.assign(floatingElement.style, {
          position: v.strategy,
          left: `${v.x}px`,
          top: `${v.y}px`
        });
        (options == null ? void 0 : options.onComputed) && options.onComputed(v);
      });
    }
  };
  const referenceAction = (node) => {
    if ("subscribe" in node) {
      setupVirtualElementObserver(node);
      return {};
    } else {
      referenceElement = node;
      updatePosition();
    }
  };
  const contentAction = (node, contentOptions) => {
    let autoUpdateDestroy;
    floatingElement = node;
    options = getOptions(contentOptions);
    setTimeout(() => updatePosition(contentOptions), 0);
    updatePosition(contentOptions);
    const destroyAutoUpdate = () => {
      if (autoUpdateDestroy) {
        autoUpdateDestroy();
        autoUpdateDestroy = void 0;
      }
    };
    const initAutoUpdate = ({ autoUpdate: autoUpdate2 } = options || {}) => {
      destroyAutoUpdate();
      if (autoUpdate2 !== false) {
        tick().then(() => {
          return autoUpdate(referenceElement, floatingElement, () => updatePosition(options), autoUpdate2 === true ? {} : autoUpdate2);
        });
      }
      return;
    };
    autoUpdateDestroy = initAutoUpdate();
    return {
      update(contentOptions2) {
        updatePosition(contentOptions2);
        autoUpdateDestroy = initAutoUpdate(contentOptions2);
      },
      destroy() {
        destroyAutoUpdate();
      }
    };
  };
  const setupVirtualElementObserver = (node) => {
    const unsubscribe = node.subscribe(($node) => {
      if (referenceElement === void 0) {
        referenceElement = $node;
        updatePosition();
      } else {
        Object.assign(referenceElement, $node);
        updatePosition();
      }
    });
    onDestroy(unsubscribe);
  };
  return [
    referenceAction,
    contentAction,
    updatePosition
  ];
}

// node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/filter.js
function filter({
  loadOptions,
  filterText,
  items,
  multiple,
  value,
  itemId,
  groupBy,
  filterSelectedItems,
  itemFilter,
  convertStringItemsToObjects,
  filterGroupedItems,
  label
}) {
  if (items && loadOptions) return items;
  if (!items) return [];
  if (items && items.length > 0 && typeof items[0] !== "object") {
    items = convertStringItemsToObjects(items);
  }
  let filterResults = items.filter((item) => {
    let matchesFilter = itemFilter(item[label], filterText, item);
    if (matchesFilter && multiple && (value == null ? void 0 : value.length)) {
      matchesFilter = !value.some((x) => {
        return filterSelectedItems ? x[itemId] === item[itemId] : false;
      });
    }
    return matchesFilter;
  });
  if (groupBy) {
    filterResults = filterGroupedItems(filterResults);
  }
  return filterResults;
}

// node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/get-items.js
async function getItems({ dispatch, loadOptions, convertStringItemsToObjects, filterText }) {
  let res = await loadOptions(filterText).catch((err) => {
    console.warn("svelte-select loadOptions error :>> ", err);
    dispatch("error", { type: "loadOptions", details: err });
  });
  if (res && !res.cancelled) {
    if (res) {
      if (res && res.length > 0 && typeof res[0] !== "object") {
        res = convertStringItemsToObjects(res);
      }
      dispatch("loaded", { items: res });
    } else {
      res = [];
    }
    return {
      filteredItems: res,
      loading: false,
      focused: true,
      listOpen: true
    };
  }
}

// node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/ChevronIcon.svelte
ChevronIcon[FILENAME] = "node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/ChevronIcon.svelte";
var root = add_locations(
  ns_template(`<svg width="100%" height="100%" viewBox="0 0 20 20" focusable="false" aria-hidden="true" class="s-aCcW0ImqMjk0"><path fill="currentColor" d="M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747
          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0
          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502
          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0
          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"></path></svg>`),
  ChevronIcon[FILENAME],
  [[1, 0, [[7, 4]]]]
);
var $$css = {
  hash: "s-aCcW0ImqMjk0",
  code: "\n  svg.s-aCcW0ImqMjk0 {\n      width: var(--chevron-icon-width, 20px);\n      height: var(--chevron-icon-width, 20px);\n      color: var(--chevron-icon-colour, currentColor);\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hldnJvbkljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiI7QUFnQkEsRUFBRSxrQkFBRyxDQUFDO0FBQ04sTUFBTSxzQ0FBc0M7QUFDNUMsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSwrQ0FBK0M7QUFDckQiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkNoZXZyb25JY29uLnN2ZWx0ZSJdfQ== */"
};
function ChevronIcon($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ChevronIcon);
  append_styles($$anchor, $$css);
  var svg = root();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronIcon = hmr(ChevronIcon, () => ChevronIcon[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-aCcW0ImqMjk0");
    module.default[HMR].source = ChevronIcon[HMR].source;
    set(ChevronIcon[HMR].source, module.default[HMR].original);
  });
}
var ChevronIcon_default = ChevronIcon;

// node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/ClearIcon.svelte
ClearIcon[FILENAME] = "node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/ClearIcon.svelte";
var root2 = add_locations(
  ns_template(`<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" aria-hidden="true" role="presentation" class="s-6DO0k49_ULiZ"><path fill="currentColor" d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124
    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>`),
  ClearIcon[FILENAME],
  [[1, 0, [[9, 4]]]]
);
var $$css2 = {
  hash: "s-6DO0k49_ULiZ",
  code: "\n    svg.s-6DO0k49_ULiZ {\n        width: var(--clear-icon-width, 20px);\n        height: var(--clear-icon-width, 20px);\n        color: var(--clear-icon-color, currentColor);\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2xlYXJJY29uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiO0FBZ0JBLElBQUksa0JBQUcsQ0FBQztBQUNSLFFBQVEsb0NBQW9DO0FBQzVDLFFBQVEscUNBQXFDO0FBQzdDLFFBQVEsNENBQTRDO0FBQ3BEIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJDbGVhckljb24uc3ZlbHRlIl19 */"
};
function ClearIcon($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ClearIcon);
  append_styles($$anchor, $$css2);
  var svg = root2();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClearIcon = hmr(ClearIcon, () => ClearIcon[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-6DO0k49_ULiZ");
    module.default[HMR].source = ClearIcon[HMR].source;
    set(ClearIcon[HMR].source, module.default[HMR].original);
  });
}
var ClearIcon_default = ClearIcon;

// node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/LoadingIcon.svelte
LoadingIcon[FILENAME] = "node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/LoadingIcon.svelte";
var root3 = add_locations(ns_template(`<svg class="loading s-NL02vcoHDYfd" viewBox="25 25 50 50"><circle class="circle_path s-NL02vcoHDYfd" cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10"></circle></svg>`), LoadingIcon[FILENAME], [[1, 0, [[2, 4]]]]);
var $$css3 = {
  hash: "s-NL02vcoHDYfd",
  code: "\n    .loading.s-NL02vcoHDYfd {\n        width: var(--spinner-width, 20px);\n        height: var(--spinner-height, 20px);\n        color: var(--spinner-color, var(--icons-color));\n        animation: s-NL02vcoHDYfd-rotate 0.75s linear infinite;\n        transform-origin: center center;\n        transform: none;\n    }\n\n    .circle_path.s-NL02vcoHDYfd {\n        stroke-dasharray: 90;\n        stroke-linecap: round;\n    }\n\n    @keyframes s-NL02vcoHDYfd-rotate {\n        100% {\n            transform: rotate(360deg);\n        }\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGluZ0ljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiI7QUFhQSxJQUFJLHVCQUFRLENBQUM7QUFDYixRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG1DQUFtQztBQUMzQyxRQUFRLCtDQUErQztBQUN2RCxRQUFRLDBCQUFXLDRCQUE0QjtBQUMvQyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLGVBQWU7QUFDdkI7O0FBRUEsSUFBSSwyQkFBWSxDQUFDO0FBQ2pCLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEscUJBQXFCO0FBQzdCOztBQUVBLElBQUksMEJBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQSIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiTG9hZGluZ0ljb24uc3ZlbHRlIl19 */"
};
function LoadingIcon($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, LoadingIcon);
  append_styles($$anchor, $$css3);
  var svg = root3();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LoadingIcon = hmr(LoadingIcon, () => LoadingIcon[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-NL02vcoHDYfd");
    module.default[HMR].source = LoadingIcon[HMR].source;
    set(LoadingIcon[HMR].source, module.default[HMR].original);
  });
}
var LoadingIcon_default = LoadingIcon;

// node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/Select.svelte
Select[FILENAME] = "node_modules/.pnpm/svelte-select@5.8.3/node_modules/svelte-select/Select.svelte";
var root_6 = add_locations(template(`<div class="list-item s-w8mBBiMFED5R" tabindex="-1" role="none"><div><!></div></div>`), Select[FILENAME], [[700, 20, [[708, 24]]]]);
var root_10 = add_locations(template(`<div class="empty s-w8mBBiMFED5R">No options</div>`), Select[FILENAME], [[726, 20]]);
var root_1 = add_locations(template(`<div role="none"><!> <!> <!></div>`), Select[FILENAME], [[687, 8]]);
var root_12 = add_locations(template(`<span id="aria-selection" class="s-w8mBBiMFED5R"> </span> <span id="aria-context" class="s-w8mBBiMFED5R"> </span>`, 1), Select[FILENAME], [[735, 12], [736, 12]]);
var root_17 = add_locations(template(`<div class="multi-item-clear s-w8mBBiMFED5R"><!></div>`), Select[FILENAME], [[764, 28]]);
var root_15 = add_locations(template(`<div role="none"><span class="multi-item-text s-w8mBBiMFED5R"><!></span> <!></div>`), Select[FILENAME], [[750, 20, [[757, 24]]]]);
var root_19 = add_locations(template(`<div><!></div>`), Select[FILENAME], [[775, 16]]);
var root_21 = add_locations(template(`<div class="icon loading s-w8mBBiMFED5R" aria-hidden="true"><!></div>`), Select[FILENAME], [[798, 12]]);
var root_23 = add_locations(template(`<button type="button" class="icon clear-select s-w8mBBiMFED5R"><!></button>`), Select[FILENAME], [[806, 12]]);
var root_25 = add_locations(template(`<div class="icon chevron s-w8mBBiMFED5R" aria-hidden="true"><!></div>`), Select[FILENAME], [[814, 12]]);
var root_27 = add_locations(template(`<input type="hidden" class="s-w8mBBiMFED5R">`), Select[FILENAME], [[823, 8]]);
var root_29 = add_locations(template(`<select class="required s-w8mBBiMFED5R" required tabindex="-1" aria-hidden="true"></select>`), Select[FILENAME], [[828, 12]]);
var root4 = add_locations(template(`<div role="none"><!> <span aria-live="polite" aria-atomic="false" aria-relevant="additions text" class="a11y-text s-w8mBBiMFED5R"><!></span> <div class="prepend s-w8mBBiMFED5R"><!></div> <div class="value-container s-w8mBBiMFED5R"><!> <input></div> <div class="indicators s-w8mBBiMFED5R"><!> <!> <!></div> <!> <!></div>`), Select[FILENAME], [
  [
    673,
    0,
    [
      [733, 4],
      [742, 4],
      [746, 4, [[783, 8]]],
      [796, 4]
    ]
  ]
]);
var $$css4 = {
  hash: "s-w8mBBiMFED5R",
  code: "\n    .svelte-select.s-w8mBBiMFED5R {\n        /* deprecating camelCase custom props in favour of kebab-case for v5 */\n        --borderRadius: var(--border-radius);\n        --clearSelectColor: var(--clear-select-color);\n        --clearSelectWidth: var(--clear-select-width);\n        --disabledBackground: var(--disabled-background);\n        --disabledBorderColor: var(--disabled-border-color);\n        --disabledColor: var(--disabled-color);\n        --disabledPlaceholderColor: var(--disabled-placeholder-color);\n        --disabledPlaceholderOpacity: var(--disabled-placeholder-opacity);\n        --errorBackground: var(--error-background);\n        --errorBorder: var(--error-border);\n        --groupItemPaddingLeft: var(--group-item-padding-left);\n        --groupTitleColor: var(--group-title-color);\n        --groupTitleFontSize: var(--group-title-font-size);\n        --groupTitleFontWeight: var(--group-title-font-weight);\n        --groupTitlePadding: var(--group-title-padding);\n        --groupTitleTextTransform: var(--group-title-text-transform);\n        --groupTitleBorderColor: var(--group-title-border-color);\n        --groupTitleBorderWidth: var(--group-title-border-width);\n        --groupTitleBorderStyle: var(--group-title-border-style);\n        --indicatorColor: var(--chevron-color);\n        --indicatorHeight: var(--chevron-height);\n        --indicatorWidth: var(--chevron-width);\n        --inputColor: var(--input-color);\n        --inputLeft: var(--input-left);\n        --inputLetterSpacing: var(--input-letter-spacing);\n        --inputMargin: var(--input-margin);\n        --inputPadding: var(--input-padding);\n        --itemActiveBackground: var(--item-active-background);\n        --itemColor: var(--item-color);\n        --itemFirstBorderRadius: var(--item-first-border-radius);\n        --itemHoverBG: var(--item-hover-bg);\n        --itemHoverColor: var(--item-hover-color);\n        --itemIsActiveBG: var(--item-is-active-bg);\n        --itemIsActiveColor: var(--item-is-active-color);\n        --itemIsNotSelectableColor: var(--item-is-not-selectable-color);\n        --itemPadding: var(--item-padding);\n        --listBackground: var(--list-background);\n        --listBorder: var(--list-border);\n        --listBorderRadius: var(--list-border-radius);\n        --listEmptyColor: var(--list-empty-color);\n        --listEmptyPadding: var(--list-empty-padding);\n        --listEmptyTextAlign: var(--list-empty-text-align);\n        --listMaxHeight: var(--list-max-height);\n        --listPosition: var(--list-position);\n        --listShadow: var(--list-shadow);\n        --listZIndex: var(--list-z-index);\n        --multiItemBG: var(--multi-item-bg);\n        --multiItemBorderRadius: var(--multi-item-border-radius);\n        --multiItemDisabledHoverBg: var(--multi-item-disabled-hover-bg);\n        --multiItemDisabledHoverColor: var(--multi-item-disabled-hover-color);\n        --multiItemHeight: var(--multi-item-height);\n        --multiItemMargin: var(--multi-item-margin);\n        --multiItemPadding: var(--multi-item-padding);\n        --multiSelectInputMargin: var(--multi-select-input-margin);\n        --multiSelectInputPadding: var(--multi-select-input-padding);\n        --multiSelectPadding: var(--multi-select-padding);\n        --placeholderColor: var(--placeholder-color);\n        --placeholderOpacity: var(--placeholder-opacity);\n        --selectedItemPadding: var(--selected-item-padding);\n        --spinnerColor: var(--spinner-color);\n        --spinnerHeight: var(--spinner-height);\n        --spinnerWidth: var(--spinner-width);\n\n        --internal-padding: 0 0 0 16px;\n\n        border: var(--border, 1px solid #d8dbdf);\n        border-radius: var(--border-radius, 6px);\n        min-height: var(--height, 42px);\n        position: relative;\n        display: flex;\n        align-items: stretch;\n        padding: var(--padding, var(--internal-padding));\n        background: var(--background, #fff);\n        margin: var(--margin, 0);\n        width: var(--width, 100%);\n        font-size: var(--font-size, 16px);\n        max-height: var(--max-height);\n    }\n\n    .s-w8mBBiMFED5R {\n        box-sizing: var(--box-sizing, border-box);\n    }\n\n    .svelte-select.s-w8mBBiMFED5R:hover {\n        border: var(--border-hover, 1px solid #b2b8bf);\n    }\n\n    .value-container.s-w8mBBiMFED5R {\n        display: flex;\n        flex: 1 1 0%;\n        flex-wrap: wrap;\n        align-items: center;\n        gap: 5px 10px;\n        padding: var(--value-container-padding, 5px 0);\n        position: relative;\n        overflow: var(--value-container-overflow, hidden);\n        align-self: stretch;\n    }\n\n    .prepend.s-w8mBBiMFED5R,\n    .indicators.s-w8mBBiMFED5R {\n        display: flex;\n        flex-shrink: 0;\n        align-items: center;\n    }\n\n    .indicators.s-w8mBBiMFED5R {\n        position: var(--indicators-position);\n        top: var(--indicators-top);\n        right: var(--indicators-right);\n        bottom: var(--indicators-bottom);\n    }\n\n    input.s-w8mBBiMFED5R {\n        position: absolute;\n        cursor: default;\n        border: none;\n        color: var(--input-color, var(--item-color));\n        padding: var(--input-padding, 0);\n        letter-spacing: var(--input-letter-spacing, inherit);\n        margin: var(--input-margin, 0);\n        min-width: 10px;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        background: transparent;\n        font-size: var(--font-size, 16px);\n    }\n\n    .s-w8mBBiMFED5R:not(.multi) > .value-container:where(.s-w8mBBiMFED5R) > input:where(.s-w8mBBiMFED5R) {\n        width: 100%;\n        height: 100%;\n    }\n\n    input.s-w8mBBiMFED5R::placeholder {\n        color: var(--placeholder-color, #78848f);\n        opacity: var(--placeholder-opacity, 1);\n    }\n\n    input.s-w8mBBiMFED5R:focus {\n        outline: none;\n    }\n\n    .svelte-select.focused.s-w8mBBiMFED5R {\n        border: var(--border-focused, 1px solid #006fe8);\n        border-radius: var(--border-radius-focused, var(--border-radius, 6px));\n    }\n\n    .disabled.s-w8mBBiMFED5R {\n        background: var(--disabled-background, #ebedef);\n        border-color: var(--disabled-border-color, #ebedef);\n        color: var(--disabled-color, #c1c6cc);\n    }\n\n    .disabled.s-w8mBBiMFED5R input:where(.s-w8mBBiMFED5R)::placeholder {\n        color: var(--disabled-placeholder-color, #c1c6cc);\n        opacity: var(--disabled-placeholder-opacity, 1);\n    }\n\n    .selected-item.s-w8mBBiMFED5R {\n        position: relative;\n        overflow: var(--selected-item-overflow, hidden);\n        padding: var(--selected-item-padding, 0 20px 0 0);\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        color: var(--selected-item-color, inherit);\n        font-size: var(--font-size, 16px);\n    }\n\n    .multi.s-w8mBBiMFED5R .selected-item:where(.s-w8mBBiMFED5R) {\n        position: absolute;\n        line-height: var(--height, 42px);\n        height: var(--height, 42px);\n    }\n\n    .selected-item.s-w8mBBiMFED5R:focus {\n        outline: none;\n    }\n\n    .hide-selected-item.s-w8mBBiMFED5R {\n        opacity: 0;\n    }\n\n    .icon.s-w8mBBiMFED5R {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .clear-select.s-w8mBBiMFED5R {\n        all: unset;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: var(--clear-select-width, 40px);\n        height: var(--clear-select-height, 100%);\n        color: var(--clear-select-color, var(--icons-color));\n        margin: var(--clear-select-margin, 0);\n        pointer-events: all;\n        flex-shrink: 0;\n    }\n\n    .clear-select.s-w8mBBiMFED5R:focus {\n        outline: var(--clear-select-focus-outline, 1px solid #006fe8);\n    }\n\n    .loading.s-w8mBBiMFED5R {\n        width: var(--loading-width, 40px);\n        height: var(--loading-height);\n        color: var(--loading-color, var(--icons-color));\n        margin: var(--loading--margin, 0);\n        flex-shrink: 0;\n    }\n\n    .chevron.s-w8mBBiMFED5R {\n        width: var(--chevron-width, 40px);\n        height: var(--chevron-height, 40px);\n        background: var(--chevron-background, transparent);\n        pointer-events: var(--chevron-pointer-events, none);\n        color: var(--chevron-color, var(--icons-color));\n        border: var(--chevron-border, 0 0 0 1px solid #d8dbdf);\n        flex-shrink: 0;\n    }\n\n    .multi.s-w8mBBiMFED5R {\n        padding: var(--multi-select-padding, var(--internal-padding));\n    }\n\n    .multi.s-w8mBBiMFED5R input:where(.s-w8mBBiMFED5R) {\n        padding: var(--multi-select-input-padding, 0);\n        position: relative;\n        margin: var(--multi-select-input-margin, 5px 0);\n        flex: 1 1 40px;\n    }\n\n    .svelte-select.error.s-w8mBBiMFED5R {\n        border: var(--error-border, 1px solid #ff2d55);\n        background: var(--error-background, #fff);\n    }\n\n    .a11y-text.s-w8mBBiMFED5R {\n        z-index: 9999;\n        border: 0px;\n        clip: rect(1px, 1px, 1px, 1px);\n        height: 1px;\n        width: 1px;\n        position: absolute;\n        overflow: hidden;\n        padding: 0px;\n        white-space: nowrap;\n    }\n\n    .multi-item.s-w8mBBiMFED5R {\n        background: var(--multi-item-bg, #ebedef);\n        margin: var(--multi-item-margin, 0);\n        outline: var(--multi-item-outline, 1px solid #ddd);\n        border-radius: var(--multi-item-border-radius, 4px);\n        height: var(--multi-item-height, 25px);\n        line-height: var(--multi-item-height, 25px);\n        display: flex;\n        cursor: default;\n        padding: var(--multi-item-padding, 0 5px);\n        overflow: hidden;\n        gap: var(--multi-item-gap, 4px);\n        outline-offset: -1px;\n        max-width: var(--multi-max-width, none);\n        color: var(--multi-item-color, var(--item-color));\n    }\n\n    .multi-item.disabled.s-w8mBBiMFED5R:hover {\n        background: var(--multi-item-disabled-hover-bg, #ebedef);\n        color: var(--multi-item-disabled-hover-color, #c1c6cc);\n    }\n\n    .multi-item-text.s-w8mBBiMFED5R {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n    }\n\n    .multi-item-clear.s-w8mBBiMFED5R {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        --clear-icon-color: var(--multi-item-clear-icon-color, #000);\n    }\n\n    .multi-item.active.s-w8mBBiMFED5R {\n        outline: var(--multi-item-active-outline, 1px solid #006fe8);\n    }\n\n    .svelte-select-list.s-w8mBBiMFED5R {\n        box-shadow: var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));\n        border-radius: var(--list-border-radius, 4px);\n        max-height: var(--list-max-height, 252px);\n        overflow-y: auto;\n        background: var(--list-background, #fff);\n        position: var(--list-position, absolute);\n        z-index: var(--list-z-index, 2);\n        border: var(--list-border);\n    }\n\n    .prefloat.s-w8mBBiMFED5R {\n        opacity: 0;\n        pointer-events: none;\n    }\n\n    .list-group-title.s-w8mBBiMFED5R {\n        color: var(--group-title-color, #8f8f8f);\n        cursor: default;\n        font-size: var(--group-title-font-size, 16px);\n        font-weight: var(--group-title-font-weight, 600);\n        height: var(--height, 42px);\n        line-height: var(--height, 42px);\n        padding: var(--group-title-padding, 0 20px);\n        text-overflow: ellipsis;\n        overflow-x: hidden;\n        white-space: nowrap;\n        text-transform: var(--group-title-text-transform, uppercase);\n        border-width: var(--group-title-border-width, medium);\n        border-style: var(--group-title-border-style, none);\n        border-color: var(--group-title-border-color, color);\n    }\n\n    .empty.s-w8mBBiMFED5R {\n        text-align: var(--list-empty-text-align, center);\n        padding: var(--list-empty-padding, 20px 0);\n        color: var(--list-empty-color, #78848f);\n    }\n\n    .item.s-w8mBBiMFED5R {\n        cursor: default;\n        height: var(--item-height, var(--height, 42px));\n        line-height: var(--item-line-height, var(--height, 42px));\n        padding: var(--item-padding, 0 20px);\n        color: var(--item-color, inherit);\n        text-overflow: ellipsis;\n        overflow: hidden;\n        white-space: nowrap;\n        transition: var(--item-transition, all 0.2s);\n        align-items: center;\n        width: 100%;\n    }\n\n    .item.group-item.s-w8mBBiMFED5R {\n        padding-left: var(--group-item-padding-left, 40px);\n    }\n\n    .item.s-w8mBBiMFED5R:active {\n        background: var(--item-active-background, #b9daff);\n    }\n\n    .item.active.s-w8mBBiMFED5R {\n        background: var(--item-is-active-bg, #007aff);\n        color: var(--item-is-active-color, #fff);\n    }\n\n    .item.first.s-w8mBBiMFED5R {\n        border-radius: var(--item-first-border-radius, 4px 4px 0 0);\n    }\n\n    .item.hover.s-w8mBBiMFED5R:not(.active) {\n        background: var(--item-hover-bg, #e7f2ff);\n        color: var(--item-hover-color, inherit);\n    }\n\n    .item.not-selectable.s-w8mBBiMFED5R,\n    .item.hover.item.not-selectable.s-w8mBBiMFED5R,\n    .item.active.item.not-selectable.s-w8mBBiMFED5R,\n    .item.not-selectable.s-w8mBBiMFED5R:active {\n        color: var(--item-is-not-selectable-color, #999);\n        background: transparent;\n    }\n\n    .required.s-w8mBBiMFED5R {\n        opacity: 0;\n        z-index: -1;\n        position: absolute;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFFBQVEsa0RBQWtEO0FBQzFEOztBQUVBLElBQUksb0JBQUssT0FBTyxDQUFDO0FBQ2pCLFFBQVEsa0RBQWtEO0FBQzFEOztBQUVBLElBQUksS0FBSyxzQkFBTyxDQUFDO0FBQ2pCLFFBQVEsNkNBQTZDO0FBQ3JELFFBQVEsd0NBQXdDO0FBQ2hEOztBQUVBLElBQUksS0FBSyxxQkFBTSxDQUFDO0FBQ2hCLFFBQVEsMkRBQTJEO0FBQ25FOztBQUVBLElBQUksS0FBSyxxQkFBTSxLQUFLLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLFFBQVEseUNBQXlDO0FBQ2pELFFBQVEsdUNBQXVDO0FBQy9DOztBQUVBLElBQUksS0FBSyw4QkFBZTtBQUN4QixJQUFJLEtBQUssTUFBTSxLQUFLLDhCQUFlO0FBQ25DLElBQUksS0FBSyxPQUFPLEtBQUssOEJBQWU7QUFDcEMsSUFBSSxLQUFLLDhCQUFlLE9BQU8sQ0FBQztBQUNoQyxRQUFRLGdEQUFnRDtBQUN4RCxRQUFRLHVCQUF1QjtBQUMvQjs7QUFFQSxJQUFJLHdCQUFTLENBQUM7QUFDZCxRQUFRLFVBQVU7QUFDbEIsUUFBUSxXQUFXO0FBQ25CLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVEsTUFBTTtBQUNkLFFBQVEsT0FBTztBQUNmLFFBQVEsU0FBUztBQUNqQixRQUFRLFFBQVE7QUFDaEIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlNlbGVjdC5zdmVsdGUiXX0= */"
};
function Select($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  push($$props, false, Select);
  append_styles($$anchor, $$css4);
  const hasValue = mutable_source();
  const hideSelectedItem = mutable_source();
  const showClear = mutable_source();
  const placeholderText = mutable_source();
  const ariaSelection = mutable_source();
  const ariaContext = mutable_source();
  const filteredItems = mutable_source();
  const listDom = mutable_source();
  const scrollToHoverItem = mutable_source();
  const dispatch = createEventDispatcher();
  let justValue = prop($$props, "justValue", 12, null);
  let filter2 = prop($$props, "filter", 8, filter);
  let getItems2 = prop($$props, "getItems", 8, getItems);
  let id = prop($$props, "id", 8, null);
  let name = prop($$props, "name", 8, null);
  let container = prop($$props, "container", 12, void 0);
  let input = prop($$props, "input", 12, void 0);
  let multiple = prop($$props, "multiple", 8, false);
  let multiFullItemClearable = prop($$props, "multiFullItemClearable", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let focused = prop($$props, "focused", 12, false);
  let value = prop($$props, "value", 12, null);
  let filterText = prop($$props, "filterText", 12, "");
  let placeholder = prop($$props, "placeholder", 8, "Please select");
  let placeholderAlwaysShow = prop($$props, "placeholderAlwaysShow", 8, false);
  let items = prop($$props, "items", 12, null);
  let label = prop($$props, "label", 8, "label");
  let itemFilter = prop($$props, "itemFilter", 8, (label2, filterText2, option) => `${label2}`.toLowerCase().includes(filterText2.toLowerCase()));
  let groupBy = prop($$props, "groupBy", 8, void 0);
  let groupFilter = prop($$props, "groupFilter", 8, (groups) => groups);
  let groupHeaderSelectable = prop($$props, "groupHeaderSelectable", 8, false);
  let itemId = prop($$props, "itemId", 8, "value");
  let loadOptions = prop($$props, "loadOptions", 8, void 0);
  let containerStyles = prop($$props, "containerStyles", 8, "");
  let hasError = prop($$props, "hasError", 8, false);
  let filterSelectedItems = prop($$props, "filterSelectedItems", 8, true);
  let required = prop($$props, "required", 8, false);
  let closeListOnChange = prop($$props, "closeListOnChange", 8, true);
  let clearFilterTextOnBlur = prop($$props, "clearFilterTextOnBlur", 8, true);
  let createGroupHeaderItem = prop($$props, "createGroupHeaderItem", 8, (groupValue, item) => {
    return { value: groupValue, [label()]: groupValue };
  });
  const getFilteredItems = () => {
    return get(filteredItems);
  };
  let searchable = prop($$props, "searchable", 8, true);
  let inputStyles = prop($$props, "inputStyles", 8, "");
  let clearable = prop($$props, "clearable", 8, true);
  let loading = prop($$props, "loading", 12, false);
  let listOpen = prop($$props, "listOpen", 12, false);
  let timeout;
  let debounce = prop($$props, "debounce", 8, (fn, wait = 1) => {
    clearTimeout(timeout);
    timeout = setTimeout(fn, wait);
  });
  let debounceWait = prop($$props, "debounceWait", 8, 300);
  let hideEmptyState = prop($$props, "hideEmptyState", 8, false);
  let inputAttributes = prop($$props, "inputAttributes", 24, () => ({}));
  let listAutoWidth = prop($$props, "listAutoWidth", 8, true);
  let showChevron = prop($$props, "showChevron", 8, false);
  let listOffset = prop($$props, "listOffset", 8, 5);
  let hoverItemIndex = prop($$props, "hoverItemIndex", 12, 0);
  let floatingConfig = prop($$props, "floatingConfig", 24, () => ({}));
  let containerClasses = prop($$props, "class", 8, "");
  let activeValue = mutable_source();
  let prev_value = mutable_source();
  let prev_filterText = mutable_source();
  let prev_multiple = mutable_source();
  function setValue() {
    if (strict_equals(typeof value(), "string")) {
      let item = (items() || []).find((item2) => strict_equals(item2[itemId()], value()));
      value(item || {
        [itemId()]: value(),
        label: value()
      });
    } else if (multiple() && Array.isArray(value()) && value().length > 0) {
      value(value().map((item) => strict_equals(typeof item, "string") ? { value: item, label: item } : item));
    }
  }
  let _inputAttributes = mutable_source();
  function assignInputAttributes() {
    set(_inputAttributes, Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      inputAttributes()
    ));
    if (id()) {
      mutate(_inputAttributes, get(_inputAttributes)["id"] = id());
    }
    if (!searchable()) {
      mutate(_inputAttributes, get(_inputAttributes)["readonly"] = true);
    }
  }
  function convertStringItemsToObjects(_items) {
    return _items.map((item, index2) => {
      return { index: index2, value: item, label: `${item}` };
    });
  }
  function filterGroupedItems(_items) {
    const groupValues = [];
    const groups = {};
    _items.forEach((item) => {
      const groupValue = groupBy()(item);
      if (!groupValues.includes(groupValue)) {
        groupValues.push(groupValue);
        groups[groupValue] = [];
        if (groupValue) {
          groups[groupValue].push(Object.assign(createGroupHeaderItem()(groupValue, item), {
            id: groupValue,
            groupHeader: true,
            selectable: groupHeaderSelectable()
          }));
        }
      }
      groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));
    });
    const sortedGroupedItems = [];
    groupFilter()(groupValues).forEach((groupValue) => {
      if (groups[groupValue]) sortedGroupedItems.push(...groups[groupValue]);
    });
    return sortedGroupedItems;
  }
  function dispatchSelectedItem() {
    if (multiple()) {
      if (strict_equals(JSON.stringify(value()), JSON.stringify(get(prev_value)), false)) {
        if (checkValueForDuplicates()) {
          dispatch("input", value());
        }
      }
      return;
    }
    if (!get(prev_value) || strict_equals(JSON.stringify(value()[itemId()]), JSON.stringify(get(prev_value)[itemId()]), false)) {
      dispatch("input", value());
    }
  }
  function setupMulti() {
    if (value()) {
      if (Array.isArray(value())) {
        value([...value()]);
      } else {
        value([value()]);
      }
    }
  }
  function setupSingle() {
    if (value()) value(null);
  }
  function setValueIndexAsHoverIndex() {
    const valueIndex = get(filteredItems).findIndex((i) => {
      return strict_equals(i[itemId()], value()[itemId()]);
    });
    checkHoverSelectable(valueIndex, true);
  }
  function dispatchHover(i) {
    dispatch("hoverItem", i);
  }
  function checkHoverSelectable(startingIndex = 0, ignoreGroup) {
    hoverItemIndex(startingIndex < 0 ? 0 : startingIndex);
    if (!ignoreGroup && groupBy() && get(filteredItems)[hoverItemIndex()] && !get(filteredItems)[hoverItemIndex()].selectable) {
      setHoverIndex(1);
    }
  }
  function setupFilterText() {
    if (!loadOptions() && strict_equals(filterText().length, 0)) return;
    if (loadOptions()) {
      debounce()(
        async function() {
          loading(true);
          let res = await getItems2()({
            dispatch,
            loadOptions: loadOptions(),
            convertStringItemsToObjects,
            filterText: filterText()
          });
          if (res) {
            loading(res.loading);
            listOpen(listOpen() ? res.listOpen : filterText().length > 0 ? true : false);
            focused(listOpen() && res.focused);
            items(groupBy() ? filterGroupedItems(res.filteredItems) : res.filteredItems);
          } else {
            loading(false);
            focused(true);
            listOpen(true);
          }
        },
        debounceWait()
      );
    } else {
      listOpen(true);
      if (multiple()) {
        set(activeValue, void 0);
      }
    }
  }
  function handleFilterEvent(items2) {
    if (listOpen()) dispatch("filter", items2);
  }
  beforeUpdate(async () => {
    set(prev_value, value());
    set(prev_filterText, filterText());
    set(prev_multiple, multiple());
  });
  function computeJustValue() {
    if (multiple()) return value() ? value().map((item) => item[itemId()]) : null;
    return value() ? value()[itemId()] : value();
  }
  function checkValueForDuplicates() {
    let noDuplicates = true;
    if (value()) {
      const ids = [];
      const uniqueValues = [];
      value().forEach((val) => {
        if (!ids.includes(val[itemId()])) {
          ids.push(val[itemId()]);
          uniqueValues.push(val);
        } else {
          noDuplicates = false;
        }
      });
      if (!noDuplicates) value(uniqueValues);
    }
    return noDuplicates;
  }
  function findItem(selection) {
    let matchTo = selection ? selection[itemId()] : value()[itemId()];
    return items().find((item) => strict_equals(item[itemId()], matchTo));
  }
  function updateValueDisplay(items2) {
    if (!items2 || strict_equals(items2.length, 0) || items2.some((item) => strict_equals(typeof item, "object", false))) return;
    if (!value() || (multiple() ? value().some((selection) => !selection || !selection[itemId()]) : !value()[itemId()])) return;
    if (Array.isArray(value())) {
      value(value().map((selection) => findItem(selection) || selection));
    } else {
      value(findItem() || value());
    }
  }
  async function handleMultiItemClear(i) {
    const itemToRemove = value()[i];
    if (strict_equals(value().length, 1)) {
      value(void 0);
    } else {
      value(value().filter((item) => {
        return strict_equals(item, itemToRemove, false);
      }));
    }
    dispatch("clear", itemToRemove);
  }
  function handleKeyDown(e) {
    if (!focused()) return;
    e.stopPropagation();
    switch (e.key) {
      case "Escape":
        e.preventDefault();
        closeList();
        break;
      case "Enter":
        e.preventDefault();
        if (listOpen()) {
          if (strict_equals(get(filteredItems).length, 0)) break;
          const hoverItem = get(filteredItems)[hoverItemIndex()];
          if (value() && !multiple() && strict_equals(value()[itemId()], hoverItem[itemId()])) {
            closeList();
            break;
          } else {
            handleSelect(get(filteredItems)[hoverItemIndex()]);
          }
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        if (listOpen()) {
          setHoverIndex(1);
        } else {
          listOpen(true);
          set(activeValue, void 0);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (listOpen()) {
          setHoverIndex(-1);
        } else {
          listOpen(true);
          set(activeValue, void 0);
        }
        break;
      case "Tab":
        if (listOpen() && focused()) {
          if (strict_equals(get(filteredItems).length, 0) || value() && strict_equals(value()[itemId()], get(filteredItems)[hoverItemIndex()][itemId()])) return closeList();
          e.preventDefault();
          handleSelect(get(filteredItems)[hoverItemIndex()]);
          closeList();
        }
        break;
      case "Backspace":
        if (!multiple() || filterText().length > 0) return;
        if (multiple() && value() && value().length > 0) {
          handleMultiItemClear(strict_equals(get(activeValue), void 0, false) ? get(activeValue) : value().length - 1);
          if (strict_equals(get(activeValue), 0) || strict_equals(get(activeValue), void 0)) break;
          set(activeValue, value().length > get(activeValue) ? get(activeValue) - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!value() || !multiple() || filterText().length > 0) return;
        if (strict_equals(get(activeValue), void 0)) {
          set(activeValue, value().length - 1);
        } else if (value().length > get(activeValue) && strict_equals(get(activeValue), 0, false)) {
          set(activeValue, get(activeValue) - 1);
        }
        break;
      case "ArrowRight":
        if (!value() || !multiple() || filterText().length > 0 || strict_equals(get(activeValue), void 0)) return;
        if (strict_equals(get(activeValue), value().length - 1)) {
          set(activeValue, void 0);
        } else if (get(activeValue) < value().length - 1) {
          set(activeValue, get(activeValue) + 1);
        }
        break;
    }
  }
  function handleFocus(e) {
    var _a;
    if (focused() && strict_equals(input(), document == null ? void 0 : document.activeElement)) return;
    if (e) dispatch("focus", e);
    (_a = input()) == null ? void 0 : _a.focus();
    focused(true);
  }
  async function handleBlur(e) {
    var _a;
    if (isScrolling) return;
    if (listOpen() || focused()) {
      dispatch("blur", e);
      closeList();
      focused(false);
      set(activeValue, void 0);
      (_a = input()) == null ? void 0 : _a.blur();
    }
  }
  function handleClick() {
    if (disabled()) return;
    if (filterText().length > 0) return listOpen(true);
    listOpen(!listOpen());
  }
  function handleClear() {
    dispatch("clear", value());
    value(void 0);
    closeList();
    handleFocus();
  }
  onMount(() => {
    if (listOpen()) focused(true);
    if (focused() && input()) input().focus();
  });
  function itemSelected(selection) {
    if (selection) {
      filterText("");
      const item = Object.assign({}, selection);
      if (item.groupHeader && !item.selectable) return;
      value(multiple() ? value() ? value().concat([item]) : [item] : value(item));
      setTimeout(() => {
        if (closeListOnChange()) closeList();
        set(activeValue, void 0);
        dispatch("change", value());
        dispatch("select", selection);
      });
    }
  }
  function closeList() {
    if (clearFilterTextOnBlur()) {
      filterText("");
    }
    listOpen(false);
  }
  let ariaValues = prop($$props, "ariaValues", 8, (values) => {
    return `Option ${values}, selected.`;
  });
  let ariaListOpen = prop($$props, "ariaListOpen", 8, (label2, count) => {
    return `You are currently focused on option ${label2}. There are ${count} results available.`;
  });
  let ariaFocused = prop($$props, "ariaFocused", 8, () => {
    return `Select is focused, type to refine list, press down to open the menu.`;
  });
  function handleAriaSelection(_multiple) {
    let selected = void 0;
    if (_multiple && value().length > 0) {
      selected = value().map((v) => v[label()]).join(", ");
    } else {
      selected = value()[label()];
    }
    return ariaValues()(selected);
  }
  function handleAriaContent() {
    if (!get(filteredItems) || strict_equals(get(filteredItems).length, 0)) return "";
    let _item = get(filteredItems)[hoverItemIndex()];
    if (listOpen() && _item) {
      let count = get(filteredItems) ? get(filteredItems).length : 0;
      return ariaListOpen()(_item[label()], count);
    } else {
      return ariaFocused()();
    }
  }
  let list = mutable_source(null);
  let isScrollingTimer;
  function handleListScroll() {
    clearTimeout(isScrollingTimer);
    isScrollingTimer = setTimeout(
      () => {
        isScrolling = false;
      },
      100
    );
  }
  function handleClickOutside(event2) {
    var _a;
    if (!listOpen() && !focused() && container() && !container().contains(event2.target) && !((_a = get(list)) == null ? void 0 : _a.contains(event2.target))) {
      handleBlur();
    }
  }
  onDestroy(() => {
    var _a;
    (_a = get(list)) == null ? void 0 : _a.remove();
  });
  let isScrolling = false;
  function handleSelect(item) {
    if (!item || strict_equals(item.selectable, false)) return;
    itemSelected(item);
  }
  function handleHover(i) {
    if (isScrolling) return;
    hoverItemIndex(i);
  }
  function handleItemClick(args) {
    const { item, i } = args;
    if (strict_equals(item == null ? void 0 : item.selectable, false)) return;
    if (value() && !multiple() && strict_equals(value()[itemId()], item[itemId()])) return closeList();
    if (isItemSelectable(item)) {
      hoverItemIndex(i);
      handleSelect(item);
    }
  }
  function setHoverIndex(increment) {
    let selectableFilteredItems = get(filteredItems).filter((item) => !Object.hasOwn(item, "selectable") || strict_equals(item.selectable, true));
    if (strict_equals(selectableFilteredItems.length, 0)) {
      return hoverItemIndex(0);
    }
    if (increment > 0 && strict_equals(hoverItemIndex(), get(filteredItems).length - 1)) {
      hoverItemIndex(0);
    } else if (increment < 0 && strict_equals(hoverItemIndex(), 0)) {
      hoverItemIndex(get(filteredItems).length - 1);
    } else {
      hoverItemIndex(hoverItemIndex() + increment);
    }
    const hover = get(filteredItems)[hoverItemIndex()];
    if (hover && strict_equals(hover.selectable, false)) {
      if (strict_equals(increment, 1) || strict_equals(increment, -1)) setHoverIndex(increment);
      return;
    }
  }
  function isItemActive(item, value2, itemId2) {
    if (multiple()) return;
    return value2 && strict_equals(value2[itemId2], item[itemId2]);
  }
  function isItemFirst(itemIndex) {
    return strict_equals(itemIndex, 0);
  }
  function isItemSelectable(item) {
    return item.groupHeader && item.selectable || item.selectable || !item.hasOwnProperty("selectable");
  }
  const activeScroll = scrollAction;
  const hoverScroll = scrollAction;
  function scrollAction(node) {
    return {
      update(args) {
        if (args.scroll) {
          handleListScroll();
          node.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      }
    };
  }
  function setListWidth() {
    const { width } = container().getBoundingClientRect();
    mutate(list, get(list).style.width = listAutoWidth() ? width + "px" : "auto");
  }
  let _floatingConfig = mutable_source({
    strategy: "absolute",
    placement: "bottom-start",
    middleware: [
      offset2(listOffset()),
      flip2(),
      shift2()
    ],
    autoUpdate: false
  });
  const [floatingRef, floatingContent, floatingUpdate] = createFloatingActions(get(_floatingConfig));
  let prefloat = mutable_source(true);
  function listMounted(list2, listOpen2) {
    if (!list2 || !listOpen2) return set(prefloat, true);
    setTimeout(
      () => {
        set(prefloat, false);
      },
      0
    );
  }
  legacy_pre_effect(
    () => (deep_read_state(items()), deep_read_state(value())),
    () => {
      if (items(), value()) setValue();
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(inputAttributes()), deep_read_state(searchable())),
    () => {
      if (inputAttributes() || !searchable()) assignInputAttributes();
    }
  );
  legacy_pre_effect(() => deep_read_state(multiple()), () => {
    if (multiple()) setupMulti();
  });
  legacy_pre_effect(
    () => (get(prev_multiple), deep_read_state(multiple())),
    () => {
      if (get(prev_multiple) && !multiple()) setupSingle();
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(multiple()), deep_read_state(value())),
    () => {
      if (multiple() && value() && value().length > 1) checkValueForDuplicates();
    }
  );
  legacy_pre_effect(() => deep_read_state(value()), () => {
    if (value()) dispatchSelectedItem();
  });
  legacy_pre_effect(
    () => (deep_read_state(value()), deep_read_state(multiple()), get(prev_value)),
    () => {
      if (!value() && multiple() && get(prev_value)) dispatch("input", value());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(focused()), deep_read_state(input())),
    () => {
      if (!focused() && input()) closeList();
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(filterText()), get(prev_filterText)),
    () => {
      if (strict_equals(filterText(), get(prev_filterText), false)) setupFilterText();
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(filter2()), deep_read_state(loadOptions()), deep_read_state(filterText()), deep_read_state(items()), deep_read_state(multiple()), deep_read_state(value()), deep_read_state(itemId()), deep_read_state(groupBy()), deep_read_state(label()), deep_read_state(filterSelectedItems()), deep_read_state(itemFilter())),
    () => {
      set(filteredItems, filter2()({
        loadOptions: loadOptions(),
        filterText: filterText(),
        items: items(),
        multiple: multiple(),
        value: value(),
        itemId: itemId(),
        groupBy: groupBy(),
        label: label(),
        filterSelectedItems: filterSelectedItems(),
        itemFilter: itemFilter(),
        convertStringItemsToObjects,
        filterGroupedItems
      }));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(multiple()), deep_read_state(listOpen()), deep_read_state(value()), get(filteredItems)),
    () => {
      if (!multiple() && listOpen() && value() && get(filteredItems)) setValueIndexAsHoverIndex();
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(listOpen()), deep_read_state(multiple())),
    () => {
      if (listOpen() && multiple()) hoverItemIndex(0);
    }
  );
  legacy_pre_effect(() => deep_read_state(filterText()), () => {
    if (filterText()) hoverItemIndex(0);
  });
  legacy_pre_effect(() => deep_read_state(hoverItemIndex()), () => {
    dispatchHover(hoverItemIndex());
  });
  legacy_pre_effect(
    () => (deep_read_state(multiple()), deep_read_state(value())),
    () => {
      set(hasValue, multiple() ? value() && value().length > 0 : value());
    }
  );
  legacy_pre_effect(
    () => (get(hasValue), deep_read_state(filterText())),
    () => {
      set(hideSelectedItem, get(hasValue) && filterText().length > 0);
    }
  );
  legacy_pre_effect(
    () => (get(hasValue), deep_read_state(clearable()), deep_read_state(disabled()), deep_read_state(loading())),
    () => {
      set(showClear, get(hasValue) && clearable() && !disabled() && !loading());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(placeholderAlwaysShow()), deep_read_state(multiple()), deep_read_state(placeholder()), deep_read_state(value())),
    () => {
      var _a;
      set(placeholderText, placeholderAlwaysShow() && multiple() ? placeholder() : multiple() && strict_equals((_a = value()) == null ? void 0 : _a.length, 0) ? placeholder() : value() ? "" : placeholder());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(value()), deep_read_state(multiple())),
    () => {
      set(ariaSelection, value() ? handleAriaSelection(multiple()) : "");
    }
  );
  legacy_pre_effect(
    () => (get(filteredItems), deep_read_state(hoverItemIndex()), deep_read_state(focused()), deep_read_state(listOpen())),
    () => {
      set(ariaContext, handleAriaContent({
        filteredItems: get(filteredItems),
        hoverItemIndex: hoverItemIndex(),
        focused: focused(),
        listOpen: listOpen()
      }));
    }
  );
  legacy_pre_effect(() => deep_read_state(items()), () => {
    updateValueDisplay(items());
  });
  legacy_pre_effect(
    () => (deep_read_state(multiple()), deep_read_state(value()), deep_read_state(itemId())),
    () => {
      justValue(computeJustValue(multiple(), value(), itemId()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(multiple()), get(prev_value), deep_read_state(value())),
    () => {
      if (!multiple() && get(prev_value) && !value()) dispatch("input", value());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(listOpen()), get(filteredItems), deep_read_state(multiple()), deep_read_state(value())),
    () => {
      if (listOpen() && get(filteredItems) && !multiple() && !value()) checkHoverSelectable();
    }
  );
  legacy_pre_effect(() => get(filteredItems), () => {
    handleFilterEvent(get(filteredItems));
  });
  legacy_pre_effect(
    () => (deep_read_state(container()), deep_read_state(floatingConfig()), get(_floatingConfig)),
    () => {
      if (container() && floatingConfig()) floatingUpdate(Object.assign(get(_floatingConfig), floatingConfig()));
    }
  );
  legacy_pre_effect(() => get(list), () => {
    set(listDom, !!get(list));
  });
  legacy_pre_effect(
    () => (get(list), deep_read_state(listOpen())),
    () => {
      listMounted(get(list), listOpen());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(listOpen()), deep_read_state(container()), get(list)),
    () => {
      if (listOpen() && container() && get(list)) setListWidth();
    }
  );
  legacy_pre_effect(() => deep_read_state(hoverItemIndex()), () => {
    set(scrollToHoverItem, hoverItemIndex());
  });
  legacy_pre_effect(
    () => (deep_read_state(input()), deep_read_state(listOpen()), deep_read_state(focused())),
    () => {
      if (input() && listOpen() && !focused()) handleFocus();
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(container()), deep_read_state(floatingConfig())),
    () => {
      var _a;
      if (container() && strict_equals((_a = floatingConfig()) == null ? void 0 : _a.autoUpdate, void 0)) {
        mutate(_floatingConfig, get(_floatingConfig).autoUpdate = true);
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root4();
  event("click", $window, handleClickOutside);
  event("keydown", $window, handleKeyDown);
  let classes;
  var node_1 = child(div);
  {
    var consequent_5 = ($$anchor2) => {
      var div_1 = root_1();
      let classes_1;
      var node_2 = child(div_1);
      {
        var consequent = ($$anchor3) => {
          var fragment = comment();
          var node_3 = first_child(fragment);
          slot(node_3, $$props, "list-prepend", {}, null);
          append($$anchor3, fragment);
        };
        if_block(node_2, ($$render) => {
          if ($$slots["list-prepend"]) $$render(consequent);
        });
      }
      var node_4 = sibling(node_2, 2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_5 = first_child(fragment_1);
          slot(
            node_5,
            $$props,
            "list",
            {
              get filteredItems() {
                return get(filteredItems);
              }
            },
            null
          );
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3, $$elseif) => {
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_2 = comment();
              var node_6 = first_child(fragment_2);
              each(node_6, 1, () => get(filteredItems), index, ($$anchor5, item, i) => {
                var div_2 = root_6();
                var div_3 = child(div_2);
                let classes_2;
                var node_7 = child(div_3);
                slot(
                  node_7,
                  $$props,
                  "item",
                  {
                    get item() {
                      return get(item);
                    },
                    index: i
                  },
                  ($$anchor6) => {
                    var text2 = text();
                    template_effect(() => {
                      var _a;
                      return set_text(text2, (_a = get(item)) == null ? void 0 : _a[label()]);
                    });
                    append($$anchor6, text2);
                  }
                );
                reset(div_3);
                action(div_3, ($$node, $$action_arg) => activeScroll == null ? void 0 : activeScroll($$node, $$action_arg), () => ({
                  scroll: isItemActive(get(item), value(), itemId()),
                  listDom: get(listDom)
                }));
                action(div_3, ($$node, $$action_arg) => hoverScroll == null ? void 0 : hoverScroll($$node, $$action_arg), () => ({
                  scroll: strict_equals(get(scrollToHoverItem), i),
                  listDom: get(listDom)
                }));
                reset(div_2);
                template_effect(
                  ($0) => classes_2 = set_class(div_3, 1, "item s-w8mBBiMFED5R", null, classes_2, $0),
                  [
                    () => {
                      var _a;
                      return {
                        "list-group-title": get(item).groupHeader,
                        active: isItemActive(get(item), value(), itemId()),
                        first: isItemFirst(i),
                        hover: strict_equals(hoverItemIndex(), i),
                        "group-item": get(item).groupItem,
                        "not-selectable": strict_equals((_a = get(item)) == null ? void 0 : _a.selectable, false)
                      };
                    }
                  ],
                  derived_safe_equal
                );
                event("mouseover", div_2, () => handleHover(i));
                event("focus", div_2, () => handleHover(i));
                event("click", div_2, stopPropagation(() => handleItemClick({ item: get(item), i })));
                event("keydown", div_2, preventDefault(stopPropagation(function($$arg) {
                  bubble_event.call(this, $$props, $$arg);
                })));
                append($$anchor5, div_2);
              });
              append($$anchor4, fragment_2);
            };
            var alternate_1 = ($$anchor4, $$elseif2) => {
              {
                var consequent_3 = ($$anchor5) => {
                  var fragment_4 = comment();
                  var node_8 = first_child(fragment_4);
                  slot(node_8, $$props, "empty", {}, ($$anchor6) => {
                    var div_4 = root_10();
                    append($$anchor6, div_4);
                  });
                  append($$anchor5, fragment_4);
                };
                if_block(
                  $$anchor4,
                  ($$render) => {
                    if (!hideEmptyState()) $$render(consequent_3);
                  },
                  $$elseif2
                );
              }
            };
            if_block(
              $$anchor3,
              ($$render) => {
                if (get(filteredItems).length > 0) $$render(consequent_2);
                else $$render(alternate_1, false);
              },
              $$elseif
            );
          }
        };
        if_block(node_4, ($$render) => {
          if ($$slots.list) $$render(consequent_1);
          else $$render(alternate, false);
        });
      }
      var node_9 = sibling(node_4, 2);
      {
        var consequent_4 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_10 = first_child(fragment_5);
          slot(node_10, $$props, "list-append", {}, null);
          append($$anchor3, fragment_5);
        };
        if_block(node_9, ($$render) => {
          if ($$slots["list-append"]) $$render(consequent_4);
        });
      }
      reset(div_1);
      action(div_1, ($$node) => floatingContent == null ? void 0 : floatingContent($$node));
      bind_this(div_1, ($$value) => set(list, $$value), () => get(list));
      effect(() => event("scroll", div_1, handleListScroll));
      effect(() => event("pointerup", div_1, preventDefault(stopPropagation(function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }))));
      effect(() => event("mousedown", div_1, preventDefault(stopPropagation(function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }))));
      template_effect(($0) => classes_1 = set_class(div_1, 1, "svelte-select-list s-w8mBBiMFED5R", null, classes_1, $0), [() => ({ prefloat: get(prefloat) })], derived_safe_equal);
      append($$anchor2, div_1);
    };
    if_block(node_1, ($$render) => {
      if (listOpen()) $$render(consequent_5);
    });
  }
  var span = sibling(node_1, 2);
  var node_11 = child(span);
  {
    var consequent_6 = ($$anchor2) => {
      var fragment_6 = root_12();
      var span_1 = first_child(fragment_6);
      var text_1 = child(span_1, true);
      reset(span_1);
      var span_2 = sibling(span_1, 2);
      var text_2 = child(span_2, true);
      reset(span_2);
      template_effect(() => {
        set_text(text_1, get(ariaSelection));
        set_text(text_2, get(ariaContext));
      });
      append($$anchor2, fragment_6);
    };
    if_block(node_11, ($$render) => {
      if (focused()) $$render(consequent_6);
    });
  }
  reset(span);
  var div_5 = sibling(span, 2);
  var node_12 = child(div_5);
  slot(node_12, $$props, "prepend", {}, null);
  reset(div_5);
  var div_6 = sibling(div_5, 2);
  var node_13 = child(div_6);
  {
    var consequent_9 = ($$anchor2) => {
      var fragment_7 = comment();
      var node_14 = first_child(fragment_7);
      {
        var consequent_8 = ($$anchor3) => {
          var fragment_8 = comment();
          var node_15 = first_child(fragment_8);
          each(node_15, 1, value, index, ($$anchor4, item, i) => {
            var div_7 = root_15();
            let classes_3;
            var span_3 = child(div_7);
            var node_16 = child(span_3);
            slot(
              node_16,
              $$props,
              "selection",
              {
                get selection() {
                  return get(item);
                },
                index: i
              },
              ($$anchor5) => {
                var text_3 = text();
                template_effect(() => set_text(text_3, get(item)[label()]));
                append($$anchor5, text_3);
              }
            );
            reset(span_3);
            var node_17 = sibling(span_3, 2);
            {
              var consequent_7 = ($$anchor5) => {
                var div_8 = root_17();
                var node_18 = child(div_8);
                slot(node_18, $$props, "multi-clear-icon", {}, ($$anchor6) => {
                  var fragment_10 = comment();
                  var node_19 = first_child(fragment_10);
                  ClearIcon_default(node_19, {});
                  append($$anchor6, fragment_10);
                });
                reset(div_8);
                event("pointerup", div_8, preventDefault(stopPropagation(() => handleMultiItemClear(i))));
                append($$anchor5, div_8);
              };
              if_block(node_17, ($$render) => {
                if (!disabled() && !multiFullItemClearable() && ClearIcon_default) $$render(consequent_7);
              });
            }
            reset(div_7);
            template_effect(
              ($0) => classes_3 = set_class(div_7, 1, "multi-item s-w8mBBiMFED5R", null, classes_3, $0),
              [
                () => ({
                  active: strict_equals(get(activeValue), i),
                  disabled: disabled()
                })
              ],
              derived_safe_equal
            );
            event("click", div_7, preventDefault(() => multiFullItemClearable() ? handleMultiItemClear(i) : {}));
            event("keydown", div_7, preventDefault(stopPropagation(function($$arg) {
              bubble_event.call(this, $$props, $$arg);
            })));
            append($$anchor4, div_7);
          });
          append($$anchor3, fragment_8);
        };
        var alternate_2 = ($$anchor3) => {
          var div_9 = root_19();
          let classes_4;
          var node_20 = child(div_9);
          slot(
            node_20,
            $$props,
            "selection",
            {
              get selection() {
                return value();
              }
            },
            ($$anchor4) => {
              var text_4 = text();
              template_effect(() => set_text(text_4, value()[label()]));
              append($$anchor4, text_4);
            }
          );
          reset(div_9);
          template_effect(
            ($0) => classes_4 = set_class(div_9, 1, "selected-item s-w8mBBiMFED5R", null, classes_4, $0),
            [
              () => ({
                "hide-selected-item": get(hideSelectedItem)
              })
            ],
            derived_safe_equal
          );
          append($$anchor3, div_9);
        };
        if_block(node_14, ($$render) => {
          if (multiple()) $$render(consequent_8);
          else $$render(alternate_2, false);
        });
      }
      append($$anchor2, fragment_7);
    };
    if_block(node_13, ($$render) => {
      if (get(hasValue)) $$render(consequent_9);
    });
  }
  var input_1 = sibling(node_13, 2);
  remove_input_defaults(input_1);
  let attributes;
  bind_this(input_1, ($$value) => input($$value), () => input());
  reset(div_6);
  var div_10 = sibling(div_6, 2);
  var node_21 = child(div_10);
  {
    var consequent_10 = ($$anchor2) => {
      var div_11 = root_21();
      var node_22 = child(div_11);
      slot(node_22, $$props, "loading-icon", {}, ($$anchor3) => {
        var fragment_12 = comment();
        var node_23 = first_child(fragment_12);
        LoadingIcon_default(node_23, {});
        append($$anchor3, fragment_12);
      });
      reset(div_11);
      append($$anchor2, div_11);
    };
    if_block(node_21, ($$render) => {
      if (loading()) $$render(consequent_10);
    });
  }
  var node_24 = sibling(node_21, 2);
  {
    var consequent_11 = ($$anchor2) => {
      var button = root_23();
      var node_25 = child(button);
      slot(node_25, $$props, "clear-icon", {}, ($$anchor3) => {
        var fragment_13 = comment();
        var node_26 = first_child(fragment_13);
        ClearIcon_default(node_26, {});
        append($$anchor3, fragment_13);
      });
      reset(button);
      event("click", button, handleClear);
      append($$anchor2, button);
    };
    if_block(node_24, ($$render) => {
      if (get(showClear)) $$render(consequent_11);
    });
  }
  var node_27 = sibling(node_24, 2);
  {
    var consequent_12 = ($$anchor2) => {
      var div_12 = root_25();
      var node_28 = child(div_12);
      slot(
        node_28,
        $$props,
        "chevron-icon",
        {
          get listOpen() {
            return listOpen();
          }
        },
        ($$anchor3) => {
          var fragment_14 = comment();
          var node_29 = first_child(fragment_14);
          ChevronIcon_default(node_29, {});
          append($$anchor3, fragment_14);
        }
      );
      reset(div_12);
      append($$anchor2, div_12);
    };
    if_block(node_27, ($$render) => {
      if (showChevron()) $$render(consequent_12);
    });
  }
  reset(div_10);
  var node_30 = sibling(div_10, 2);
  slot(
    node_30,
    $$props,
    "input-hidden",
    {
      get value() {
        return value();
      }
    },
    ($$anchor2) => {
      var input_2 = root_27();
      remove_input_defaults(input_2);
      template_effect(
        ($0) => {
          set_attribute(input_2, "name", name());
          set_value(input_2, $0);
        },
        [
          () => value() ? JSON.stringify(value()) : null
        ],
        derived_safe_equal
      );
      append($$anchor2, input_2);
    }
  );
  var node_31 = sibling(node_30, 2);
  {
    var consequent_13 = ($$anchor2) => {
      var fragment_15 = comment();
      var node_32 = first_child(fragment_15);
      slot(
        node_32,
        $$props,
        "required",
        {
          get value() {
            return value();
          }
        },
        ($$anchor3) => {
          var select = root_29();
          append($$anchor3, select);
        }
      );
      append($$anchor2, fragment_15);
    };
    if_block(node_31, ($$render) => {
      if (required() && (!value() || strict_equals(value().length, 0))) $$render(consequent_13);
    });
  }
  reset(div);
  effect(() => event("pointerup", div, preventDefault(handleClick)));
  bind_this(div, ($$value) => container($$value), () => container());
  action(div, ($$node) => floatingRef == null ? void 0 : floatingRef($$node));
  template_effect(
    ($0) => {
      classes = set_class(div, 1, `svelte-select ${containerClasses() ?? ""}`, "s-w8mBBiMFED5R", classes, $0);
      set_style(div, containerStyles());
      attributes = set_attributes(
        input_1,
        attributes,
        {
          readOnly: !searchable(),
          ...get(_inputAttributes),
          placeholder: get(placeholderText),
          style: inputStyles(),
          disabled: disabled()
        },
        "s-w8mBBiMFED5R"
      );
    },
    [
      () => ({
        multi: multiple(),
        disabled: disabled(),
        focused: focused(),
        "list-open": listOpen(),
        "show-chevron": showChevron(),
        error: hasError()
      })
    ],
    derived_safe_equal
  );
  event("keydown", input_1, handleKeyDown);
  event("blur", input_1, handleBlur);
  event("focus", input_1, handleFocus);
  bind_value(input_1, filterText);
  append($$anchor, div);
  bind_prop($$props, "getFilteredItems", getFilteredItems);
  bind_prop($$props, "handleClear", handleClear);
  return pop({
    get getFilteredItems() {
      return getFilteredItems;
    },
    get handleClear() {
      return handleClear;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Select = hmr(Select, () => Select[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-w8mBBiMFED5R");
    module.default[HMR].source = Select[HMR].source;
    set(Select[HMR].source, module.default[HMR].original);
  });
}
var Select_default = Select;
export {
  Select_default as default
};
//# sourceMappingURL=svelte-select.js.map

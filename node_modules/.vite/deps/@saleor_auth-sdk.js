import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-NNIHVWYK.js";

// node_modules/.pnpm/cookie@0.6.0/node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/.pnpm/cookie@0.6.0/node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode;
      var index = 0;
      while (index < str.length) {
        var eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/.pnpm/@saleor+auth-sdk@1.0.2/node_modules/@saleor/auth-sdk/chunk-BZFBMGPG.mjs
var getAccessTokenKey = (prefix) => [prefix, "saleor_auth_access_token"].filter(Boolean).join("+");
var SaleorAccessTokenStorageHandler = class {
  constructor(storage, prefix) {
    __publicField(this, "getAccessToken", () => {
      const key = getAccessTokenKey(this.prefix);
      return this.storage.getItem(key);
    });
    __publicField(this, "setAccessToken", (token) => {
      const key = getAccessTokenKey(this.prefix);
      return this.storage.setItem(key, token);
    });
    __publicField(this, "clearAuthStorage", () => {
      const key = getAccessTokenKey(this.prefix);
      return this.storage.removeItem(key);
    });
    this.storage = storage;
    this.prefix = prefix;
  }
};

// node_modules/.pnpm/@saleor+auth-sdk@1.0.2/node_modules/@saleor/auth-sdk/chunk-263DHBMK.mjs
var getStorageAuthEventKey = (prefix) => [prefix, "saleor_storage_auth_change"].filter(Boolean).join("+");
var getStorageAuthStateKey = (prefix) => [prefix, "saleor_auth_module_auth_state"].filter(Boolean).join("+");
var getRefreshTokenKey = (prefix) => [prefix, "saleor_auth_module_refresh_token"].filter(Boolean).join("+");
var SaleorRefreshTokenStorageHandler = class {
  constructor(storage, prefix) {
    __publicField(this, "handleStorageChange", (event) => {
      const { oldValue, newValue, type, key } = event;
      if (oldValue === newValue || type !== "storage" || key !== getStorageAuthStateKey(this.prefix)) {
        return;
      }
      this.sendAuthStateEvent(newValue);
    });
    __publicField(this, "cleanup", () => {
      if (typeof window !== "undefined") {
        window.removeEventListener("storage", this.handleStorageChange);
      }
    });
    /* auth state */
    __publicField(this, "sendAuthStateEvent", (authState) => {
      if (typeof window !== "undefined") {
        const event = new CustomEvent(getStorageAuthEventKey(this.prefix), {
          detail: { authState }
        });
        window.dispatchEvent(event);
      }
    });
    __publicField(this, "getAuthState", () => this.storage.getItem(getStorageAuthStateKey(this.prefix)) || "signedOut");
    __publicField(this, "setAuthState", (authState) => {
      this.storage.setItem(getStorageAuthStateKey(this.prefix), authState);
      this.sendAuthStateEvent(authState);
    });
    /* refresh token */
    __publicField(this, "getRefreshToken", () => this.storage.getItem(getRefreshTokenKey(this.prefix)) || null);
    __publicField(this, "setRefreshToken", (token) => {
      this.storage.setItem(getRefreshTokenKey(this.prefix), token);
    });
    /* performed on logout */
    __publicField(this, "clearAuthStorage", () => {
      this.setAuthState("signedOut");
      this.storage.removeItem(getRefreshTokenKey(this.prefix));
    });
    this.storage = storage;
    this.prefix = prefix;
    if (typeof window !== "undefined") {
      window.addEventListener("storage", this.handleStorageChange);
    }
  }
};

// node_modules/.pnpm/@saleor+auth-sdk@1.0.2/node_modules/@saleor/auth-sdk/chunk-IRFIDVVY.mjs
var MILLI_MULTIPLYER = 1e3;
var decodeToken = (token) => {
  const tokenParts = token.split(".");
  const decodedTokenData = Buffer.from(tokenParts[1] || "", "base64").toString();
  const parsedTokenData = JSON.parse(decodedTokenData);
  return parsedTokenData;
};
var getTokenExpiry = (token) => {
  const parsedTokenData = decodeToken(token);
  return parsedTokenData.exp * MILLI_MULTIPLYER || 0;
};
var getTokenIss = (token) => {
  const parsedTokenData = decodeToken(token);
  return parsedTokenData.iss;
};
var isExpiredToken = (token, tokenGracePeriod) => {
  return getTokenExpiry(token) - tokenGracePeriod <= Date.now();
};
var getRequestData = (query, variables, requestInit) => ({
  ...requestInit,
  method: "POST",
  headers: {
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    query,
    variables
  })
});
var InvariantError = class extends Error {
  constructor(message) {
    super(message);
  }
};
function invariant(condition, message) {
  if (!condition) {
    throw new InvariantError(`Invariant Violation: ${message || ""}`);
  }
}

// node_modules/.pnpm/@saleor+auth-sdk@1.0.2/node_modules/@saleor/auth-sdk/chunk-K5MTKW5C.mjs
var TypedDocumentString = class extends String {
  constructor(value, __meta__) {
    super(value);
    __publicField(this, "__apiType");
    this.value = value;
    this.__meta__ = __meta__;
  }
  toString() {
    return this.value;
  }
};

// node_modules/.pnpm/@saleor+auth-sdk@1.0.2/node_modules/@saleor/auth-sdk/chunk-7JTFMRQS.mjs
var accountErrorFragment = (
  /* graphql */
  `
  fragment AccountErrorFragment on AccountError {
    code
    field
    message
  }
`
);
var TOKEN_REFRESH = new TypedDocumentString(
  /* graphql */
  `
  ${accountErrorFragment}
  mutation refreshToken($refreshToken: String!) {
    tokenRefresh(refreshToken: $refreshToken) {
      token
      errors {
        ...AccountErrorFragment
      }
    }
  }
`
);
var TOKEN_CREATE = new TypedDocumentString(
  /* graphql */
  `
  mutation tokenCreate($email: String!, $password: String!) {
    tokenCreate(email: $email, password: $password) {
      token
      refreshToken
      errors {
        message
        field
        code
      }
    }
  }
`
);
var PASSWORD_RESET = new TypedDocumentString(
  /* graphql */
  `
  mutation passwordReset($email: String!, $password: String!, $token: String!) {
    setPassword(email: $email, password: $password, token: $token) {
      token
      refreshToken
      errors {
        message
        field
        code
      }
    }
  }
`
);
var ExternalAuthenticationURL = new TypedDocumentString(
  /* graphql */
  `
  mutation externalAuthenticationUrl($pluginId: String!, $input: JSONString!) {
    externalAuthenticationUrl(pluginId: $pluginId, input: $input) {
      authenticationData
      errors {
        code
        field
        message
      }
    }
  }
`
);
var ExternalObtainAccessTokens = new TypedDocumentString(
  /* graphql */
  `
  mutation AuthObtainAccessToken($pluginId: String!, $input: JSONString!) {
    externalObtainAccessTokens(pluginId: $pluginId, input: $input) {
      token
      refreshToken
      user {
        id
        email
      }
      errors {
        field
        code
        message
      }
    }
  }
`
);

// node_modules/.pnpm/@saleor+auth-sdk@1.0.2/node_modules/@saleor/auth-sdk/chunk-VGWXFU6P.mjs
var import_cookie = __toESM(require_cookie(), 1);
var SaleorAuthClient = class {
  /**
   * Use ths method to clear event listeners from storageHandler
   *  @example
   *  ```jsx
   *  useEffect(() => {
   *    return () => {
   *      SaleorAuthClient.cleanup();
   *    }
   *  }, [])
   *  ```
   */
  constructor({
    saleorApiUrl,
    refreshTokenStorage,
    accessTokenStorage,
    onAuthRefresh,
    tokenGracePeriod,
    defaultRequestInit
  }) {
    // we'll assume a generous time of 2 seconds for api to
    // process our request
    __publicField(this, "tokenGracePeriod", 2e3);
    __publicField(this, "tokenRefreshPromise", null);
    __publicField(this, "onAuthRefresh");
    __publicField(this, "saleorApiUrl");
    /**
     * Persistent storage (for refresh token)
     */
    __publicField(this, "refreshTokenStorage");
    /**
     * Non-persistent storage for access token
     */
    __publicField(this, "acessTokenStorage");
    __publicField(this, "defaultRequestInit");
    __publicField(this, "cleanup", () => {
      var _a;
      (_a = this.refreshTokenStorage) == null ? void 0 : _a.cleanup();
    });
    __publicField(this, "runAuthorizedRequest", (input, init, additionalParams) => {
      const token = this.acessTokenStorage.getAccessToken();
      if (!token) {
        return fetch(input, init);
      }
      const headers = (init == null ? void 0 : init.headers) || {};
      const getURL = (input2) => {
        if (typeof input2 === "string") {
          return input2;
        } else if ("url" in input2) {
          return input2.url;
        } else {
          return input2.href;
        }
      };
      const iss = getTokenIss(token);
      const issuerAndDomainMatch = getURL(input) === iss;
      const shouldAddAuthorizationHeader = issuerAndDomainMatch || (additionalParams == null ? void 0 : additionalParams.allowPassingTokenToThirdPartyDomains);
      if (!issuerAndDomainMatch) {
        if (shouldAddAuthorizationHeader) {
          console.warn(
            "Token's `iss` and request URL do not match but `allowPassingTokenToThirdPartyDomains` was specified."
          );
        } else {
          console.warn(
            "Token's `iss` and request URL do not match. Not adding `Authorization` header to the request."
          );
        }
      }
      return fetch(input, {
        ...init,
        headers: shouldAddAuthorizationHeader ? { ...headers, Authorization: `Bearer ${token}` } : headers
      });
    });
    __publicField(this, "handleRequestWithTokenRefresh", async (input, requestInit, additionalParams) => {
      var _a, _b, _c, _d, _e;
      const refreshToken = (_a = this.refreshTokenStorage) == null ? void 0 : _a.getRefreshToken();
      invariant(refreshToken, "Missing refresh token in token refresh handler");
      const accessToken = this.acessTokenStorage.getAccessToken();
      if (accessToken && !isExpiredToken(accessToken, this.tokenGracePeriod)) {
        return this.fetchWithAuth(input, requestInit, additionalParams);
      }
      (_b = this.onAuthRefresh) == null ? void 0 : _b.call(this, true);
      if (this.tokenRefreshPromise) {
        const response = await this.tokenRefreshPromise;
        const res = await response.clone().json();
        const {
          errors: graphqlErrors,
          data: {
            tokenRefresh: { errors, token }
          }
        } = res;
        (_c = this.onAuthRefresh) == null ? void 0 : _c.call(this, false);
        if ((errors == null ? void 0 : errors.length) || (graphqlErrors == null ? void 0 : graphqlErrors.length) || !token) {
          this.tokenRefreshPromise = null;
          (_d = this.refreshTokenStorage) == null ? void 0 : _d.clearAuthStorage();
          return fetch(input, requestInit);
        }
        (_e = this.refreshTokenStorage) == null ? void 0 : _e.setAuthState("signedIn");
        this.acessTokenStorage.setAccessToken(token);
        this.tokenRefreshPromise = null;
        return this.runAuthorizedRequest(input, requestInit, additionalParams);
      }
      this.tokenRefreshPromise = fetch(
        this.saleorApiUrl,
        getRequestData(TOKEN_REFRESH, { refreshToken }, { ...this.defaultRequestInit, ...requestInit })
      );
      return this.fetchWithAuth(input, requestInit, additionalParams);
    });
    __publicField(this, "handleSignIn", async (response) => {
      var _a, _b, _c;
      const readResponse = await response.json();
      const responseData = "tokenCreate" in readResponse.data ? readResponse.data.tokenCreate : readResponse.data.setPassword;
      if (!responseData) {
        return readResponse;
      }
      const { errors, token, refreshToken } = responseData;
      if (!token || errors.length) {
        (_a = this.refreshTokenStorage) == null ? void 0 : _a.setAuthState("signedOut");
        return readResponse;
      }
      if (token) {
        this.acessTokenStorage.setAccessToken(token);
      }
      if (refreshToken) {
        (_b = this.refreshTokenStorage) == null ? void 0 : _b.setRefreshToken(refreshToken);
      }
      (_c = this.refreshTokenStorage) == null ? void 0 : _c.setAuthState("signedIn");
      return readResponse;
    });
    /**
     * @param additionalParams
     * @param additionalParams.allowPassingTokenToThirdPartyDomains if set to true, the `Authorization` header will be added to the request even if the token's `iss` and request URL do not match
     */
    __publicField(this, "fetchWithAuth", async (input, init, additionalParams) => {
      var _a;
      const refreshToken = (_a = this.refreshTokenStorage) == null ? void 0 : _a.getRefreshToken();
      if (!this.acessTokenStorage.getAccessToken() && typeof document !== "undefined") {
        const tokenFromCookie = import_cookie.default.parse(document.cookie).token ?? null;
        if (tokenFromCookie) {
          this.acessTokenStorage.setAccessToken(tokenFromCookie);
        }
        document.cookie = import_cookie.default.serialize("token", "", { expires: /* @__PURE__ */ new Date(0), path: "/" });
      }
      const accessToken = this.acessTokenStorage.getAccessToken();
      if (accessToken && !isExpiredToken(accessToken, this.tokenGracePeriod)) {
        return this.runAuthorizedRequest(input, init, additionalParams);
      }
      if (refreshToken) {
        return this.handleRequestWithTokenRefresh(input, init, additionalParams);
      }
      return fetch(input, init);
    });
    __publicField(this, "resetPassword", async (variables, requestInit) => {
      const response = await fetch(
        this.saleorApiUrl,
        getRequestData(PASSWORD_RESET, variables, { ...this.defaultRequestInit, ...requestInit })
      );
      return this.handleSignIn(response);
    });
    __publicField(this, "signIn", async (variables, requestInit) => {
      const response = await fetch(
        this.saleorApiUrl,
        getRequestData(TOKEN_CREATE, variables, { ...this.defaultRequestInit, ...requestInit })
      );
      return this.handleSignIn(response);
    });
    __publicField(this, "signOut", () => {
      var _a;
      this.acessTokenStorage.clearAuthStorage();
      (_a = this.refreshTokenStorage) == null ? void 0 : _a.clearAuthStorage();
      if (typeof document !== "undefined") {
        document.cookie = import_cookie.default.serialize("token", "", {
          expires: /* @__PURE__ */ new Date(0),
          path: "/"
        });
      }
    });
    this.defaultRequestInit = defaultRequestInit;
    if (tokenGracePeriod) {
      this.tokenGracePeriod = tokenGracePeriod;
    }
    this.onAuthRefresh = onAuthRefresh;
    this.saleorApiUrl = saleorApiUrl;
    const refreshTokenRepo = refreshTokenStorage ?? (typeof window !== "undefined" ? window.localStorage : void 0);
    this.refreshTokenStorage = refreshTokenRepo ? new SaleorRefreshTokenStorageHandler(refreshTokenRepo, saleorApiUrl) : null;
    const accessTokenRepo = accessTokenStorage ?? getInMemoryAccessTokenStorage();
    this.acessTokenStorage = new SaleorAccessTokenStorageHandler(accessTokenRepo, saleorApiUrl);
  }
};
var createSaleorAuthClient = (props) => new SaleorAuthClient(props);
function getInMemoryAccessTokenStorage() {
  let accessToken = null;
  return {
    getItem() {
      return accessToken;
    },
    removeItem() {
      return accessToken = null;
    },
    setItem(_key, value) {
      return accessToken = value;
    }
  };
}

// node_modules/.pnpm/@saleor+auth-sdk@1.0.2/node_modules/@saleor/auth-sdk/chunk-IYOUKX7K.mjs
var GraphQLError = class extends Error {
  constructor(errorResponse) {
    const message = errorResponse.errors.map((error) => error.message).join("\n");
    super(message);
    this.errorResponse = errorResponse;
    this.name = this.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var SaleorExternalAuth = class {
  constructor(saleorURL, provider) {
    this.saleorURL = saleorURL;
    this.provider = provider;
  }
  async makePOSTRequest(query, variables) {
    const response = await fetch(this.saleorURL, getRequestData(query, variables));
    const result = await response.json();
    if ("errors" in result) {
      console.error(result.errors);
      throw new GraphQLError(result);
    }
    return result.data;
  }
  async initiate({ redirectURL }) {
    const {
      externalAuthenticationUrl: { authenticationData: data, errors }
    } = await this.makePOSTRequest(ExternalAuthenticationURL, {
      pluginId: this.provider,
      input: JSON.stringify({ redirectUri: redirectURL })
    });
    if (errors.length > 0) {
      console.error({ errors });
      throw new GraphQLError({ errors });
    }
    const { authorizationUrl } = JSON.parse(data);
    return authorizationUrl;
  }
  async obtainAccessToken({ code, state }) {
    const { externalObtainAccessTokens: data } = await this.makePOSTRequest(ExternalObtainAccessTokens, {
      pluginId: this.provider,
      input: JSON.stringify({ code, state })
    });
    return data;
  }
};

// node_modules/.pnpm/@saleor+auth-sdk@1.0.2/node_modules/@saleor/auth-sdk/chunk-KLIEZ4V4.mjs
var ExternalProvider = ((ExternalProvider2) => {
  ExternalProvider2["OpenIDConnect"] = "mirumee.authentication.openidconnect";
  ExternalProvider2["SaleorCloud"] = "cloud_auth.CloudAuthorizationPlugin";
  return ExternalProvider2;
})(ExternalProvider || {});
export {
  ExternalProvider,
  GraphQLError,
  SaleorAuthClient,
  SaleorExternalAuth,
  createSaleorAuthClient
};
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=@saleor_auth-sdk.js.map

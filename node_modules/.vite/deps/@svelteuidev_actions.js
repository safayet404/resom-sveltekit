import "./chunk-Z2MUAD7E.js";
import "./chunk-UQRUOQQH.js";
import {
  tick
} from "./chunk-VBINPFYW.js";
import "./chunk-55T6SK4B.js";
import "./chunk-3LUZOQLA.js";
import "./chunk-2OJJ7JW3.js";
import "./chunk-NNIHVWYK.js";

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-click-outside/use-click-outside.js
function clickoutside(node, params) {
  const { enabled: initialEnabled, callback } = params;
  const handleOutsideClick = ({ target }) => {
    if (!node.contains(target))
      callback(node);
  };
  function update({ enabled }) {
    if (enabled) {
      window.addEventListener("click", handleOutsideClick);
    } else {
      window.removeEventListener("click", handleOutsideClick);
    }
  }
  update({ enabled: initialEnabled });
  return {
    update,
    destroy() {
      window.removeEventListener("click", handleOutsideClick);
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-clipboard/use-clipboard.js
function clipboard(node, text) {
  const click = async () => {
    if (text)
      try {
        await navigator.clipboard.writeText(text);
        node.dispatchEvent(new CustomEvent("useclipboard", { detail: text }));
      } catch (e) {
        node.dispatchEvent(new CustomEvent("useclipboard-error", { detail: e }));
      }
  };
  node.addEventListener("click", click, true);
  return {
    update: (t) => text = t,
    destroy: () => node.removeEventListener("click", click, true)
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-css-variable/use-css-variable.js
function cssvariable(node, props) {
  Object.entries(props).forEach(([key, value]) => {
    node.style.setProperty(`--${key}`, `${value}`);
  });
  return {
    update(_props) {
      Object.entries(_props).forEach(([key, value]) => {
        node.style.setProperty(`--${key}`, `${value}`);
        delete props[key];
      });
      Object.keys(props).forEach((name) => node.style.removeProperty(`--${name}`));
      props = _props;
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-download/use-download.js
function download(node, params) {
  const click = async () => {
    const { blob, filename } = params;
    try {
      const anchor = document.createElement("a");
      const url = URL.createObjectURL(blob);
      anchor.href = url;
      anchor.download = filename || "";
      document.body.appendChild(anchor);
      anchor.click();
      await tick();
      document.body.removeChild(anchor);
      URL.revokeObjectURL(url);
      node.dispatchEvent(new CustomEvent("usedownload", { detail: { blob, filename } }));
    } catch (e) {
      node.dispatchEvent(new CustomEvent("usedownload-error", { detail: { blob, filename } }));
    }
  };
  node.addEventListener("click", click, true);
  return {
    update: (_params) => params = _params,
    destroy: () => node.removeEventListener("click", click, true)
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-focus/use-focus.js
function focus(node) {
  node.focus();
  return;
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-hot-key/parse-hotkey.js
function parseHotkey(hotkey2) {
  const keys = hotkey2.toLowerCase().split("+").map((part) => part.trim());
  const modifiers = {
    alt: keys.includes("alt"),
    ctrl: keys.includes("ctrl"),
    meta: keys.includes("meta"),
    mod: keys.includes("mod"),
    shift: keys.includes("shift")
  };
  const reservedKeys = ["alt", "ctrl", "meta", "shift", "mod"];
  const freeKey = keys.find((key) => !reservedKeys.includes(key));
  return {
    ...modifiers,
    key: freeKey
  };
}
function isExactHotkey(hotkey2, event) {
  const { alt, ctrl, meta, mod, shift, key } = hotkey2;
  const { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey } = event;
  if (alt !== altKey) {
    return false;
  }
  if (mod) {
    if (!ctrlKey && !metaKey) {
      return false;
    }
  } else {
    if (ctrl !== ctrlKey) {
      return false;
    }
    if (meta !== metaKey) {
      return false;
    }
  }
  if (shift !== shiftKey) {
    return false;
  }
  if (key && (pressedKey.toLowerCase() === key.toLowerCase() || event.code.replace("Key", "").toLowerCase() === key.toLowerCase())) {
    return true;
  }
  return false;
}
function getHotkeyMatcher(hotkey2) {
  return (event) => isExactHotkey(parseHotkey(hotkey2), event);
}
function getHotkeyHandler(hotkeys) {
  return (event) => {
    hotkeys.forEach(([hotkey2, handler]) => {
      if (getHotkeyMatcher(hotkey2)(event)) {
        event.preventDefault();
        handler(event);
      }
    });
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-hot-key/use-hot-key.js
function shouldFireEvent(event) {
  if (event.target instanceof HTMLElement) {
    return !["INPUT", "TEXTAREA", "SELECT"].includes(event.target.tagName);
  }
}
function hotkey(node, hotkeys) {
  const keyDownListener = (event) => {
    hotkeys.forEach(([hotkey2, handler]) => {
      if (getHotkeyMatcher(hotkey2)(event) && shouldFireEvent(event)) {
        event.preventDefault();
        handler(event);
      }
    });
  };
  document.documentElement.addEventListener("keydown", keyDownListener);
  return {
    update: (updatedHotKeys) => {
      hotkeys = updatedHotKeys;
    },
    destroy: () => {
      document.documentElement.addEventListener("keydown", keyDownListener);
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-io/use-io.js
var createEvent = (name, detail) => new CustomEvent(name, { detail });
var defaultOptions = {
  root: null,
  rootMargin: "0px",
  threshold: 0,
  unobserveOnEnter: false
};
function io(node, options = {}) {
  const { root, rootMargin, threshold, unobserveOnEnter } = { ...defaultOptions, ...options };
  let prevPosition = {
    x: void 0,
    y: void 0
  };
  const scrollDirection = {
    vertical: void 0,
    horizontal: void 0
  };
  if (typeof IntersectionObserver !== "undefined" && node) {
    const observer2 = new IntersectionObserver((entries, _observer) => {
      entries.forEach((singleEntry) => {
        if (prevPosition.y > singleEntry.boundingClientRect.y) {
          scrollDirection.vertical = "up";
        } else {
          scrollDirection.vertical = "down";
        }
        if (prevPosition.x > singleEntry.boundingClientRect.x) {
          scrollDirection.horizontal = "left";
        } else {
          scrollDirection.horizontal = "right";
        }
        prevPosition = {
          y: singleEntry.boundingClientRect.y,
          x: singleEntry.boundingClientRect.x
        };
        const detail = {
          inView: singleEntry.isIntersecting,
          entry: singleEntry,
          scrollDirection,
          node,
          observer: _observer
        };
        node.dispatchEvent(createEvent("change", detail));
        if (singleEntry.isIntersecting) {
          node.dispatchEvent(createEvent("enter", detail));
          unobserveOnEnter && _observer.unobserve(node);
        } else {
          node.dispatchEvent(createEvent("leave", detail));
        }
      });
    }, {
      root,
      rootMargin,
      threshold
    });
    setTimeout(() => {
      node.dispatchEvent(createEvent("init", { observer: observer2, node }));
    }, 0);
    observer2.observe(node);
    return {
      destroy: () => {
        observer2.unobserve(node);
      }
    };
  }
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-io/use-io.config.js
var use_io_config_exports = {};

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-lazy/use-lazy.js
var nodeAttributesMap = /* @__PURE__ */ new WeakMap();
var intersection_handler = (entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting && entry.target instanceof HTMLElement) {
      const node = entry.target;
      Object.assign(node, nodeAttributesMap.get(node));
      lazyLoadObserver.unobserve(node);
    }
  });
};
var lazyLoadObserver;
function observer() {
  return lazyLoadObserver ?? (lazyLoadObserver = new IntersectionObserver(intersection_handler));
}
function lazy(node, attributes) {
  nodeAttributesMap.set(node, attributes);
  observer().observe(node);
  return {
    destroy() {
      observer().unobserve(node);
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-lock-scroll/utils/create-style-tag.js
function createStyleTag() {
  const tag = document.createElement("style");
  tag.type = "text/css";
  tag.setAttribute("svelteui-scroll-lock", "");
  return tag;
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-lock-scroll/utils/get-scroll-width.js
function getScrollWidth() {
  if (typeof window === "undefined" || typeof document === "undefined")
    return 0;
  const paddingRight = parseInt(window.getComputedStyle(document.body).paddingRight, 10);
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  return paddingRight + scrollbarWidth;
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-lock-scroll/utils/get-lock-styles.js
var getLockStyles = ({ disableBodyPadding }) => {
  const scrollWidth = disableBodyPadding ? null : getScrollWidth();
  const styles = `body {
        --removed-scroll-width: ${scrollWidth}px;
        touch-action: none;
        overflow: hidden !important;
        position: relative !important;
        ${scrollWidth ? "padding-right: var(--removed-scroll-width) !important;" : ""}
        `;
  return styles;
};

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-lock-scroll/utils/inject-style-tag.js
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-lock-scroll/utils/insert-style-tag.js
function insertStyleTag(tag) {
  const head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/utils/environment.js
var isBrowser = () => typeof window !== "undefined";
var ENVIRONMENT = {
  browser: isBrowser(),
  server: !isBrowser()
};
var defaultWindow = ENVIRONMENT.browser ? window : void 0;

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-lock-scroll/use-lock-scroll.js
function lockscroll(node, lock, options = { disableBodyPadding: false }) {
  const { browser } = ENVIRONMENT;
  let window2;
  if (browser) {
    window2 = defaultWindow;
  }
  let scrollLocked = lock ?? false;
  const { disableBodyPadding } = options;
  let stylesheet;
  const lockScroll = () => {
    const styles = getLockStyles({ disableBodyPadding });
    const sheet = createStyleTag();
    injectStyles(sheet, styles);
    insertStyleTag(sheet);
    stylesheet = sheet;
  };
  const unlockScroll = () => {
    var _a;
    if (!stylesheet)
      return;
    (_a = stylesheet == null ? void 0 : stylesheet.parentNode) == null ? void 0 : _a.removeChild(stylesheet);
    stylesheet = null;
  };
  if (scrollLocked) {
    lockScroll();
  } else {
    unlockScroll();
  }
  if (lock !== void 0) {
    scrollLocked = lock;
  }
  if (lock === void 0 && typeof window2 !== "undefined") {
    window2.document.body.style.overflow === "hidden" && (scrollLocked = lock);
  }
  return {
    update: (locked) => {
      if (locked) {
        lockScroll();
      } else {
        window2.document.body.style.overflow === "visible" && (scrollLocked = lock);
        unlockScroll();
      }
    },
    destroy: () => {
      unlockScroll();
      return;
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-long-press/use-long-press.js
function longpress(node, duration) {
  let timer;
  function handlePress() {
    timer = window.setTimeout(() => {
      node.dispatchEvent(new CustomEvent("uselongpress"));
    }, duration);
  }
  function handleRelease() {
    clearTimeout(timer);
  }
  node.addEventListener("mousedown", handlePress);
  node.addEventListener("mouseup", handleRelease);
  node.addEventListener("touchstart", handlePress);
  node.addEventListener("touchend", handleRelease);
  return {
    update(newDuration) {
      handleRelease();
      duration = newDuration;
    },
    destroy() {
      handleRelease();
      node.removeEventListener("mousedown", handlePress);
      node.removeEventListener("mouseup", handleRelease);
      node.removeEventListener("touchstart", handlePress);
      node.removeEventListener("touchstart", handleRelease);
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-page-leave/use-page-leave.js
function pageleave(node, callback) {
  document.documentElement.addEventListener("mouseleave", callback);
  return {
    destroy() {
      document.documentElement.removeEventListener("mouseleave", callback);
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-persistent-tab/use-persistent-tab.js
function persistenttab(node, enabled) {
  function handler(e) {
    e.preventDefault();
    e.returnValue = "";
  }
  function setHandler(prevent) {
    (prevent ? window.addEventListener : window.removeEventListener)("beforeunload", handler);
  }
  setHandler(enabled);
  return {
    update: setHandler,
    destroy() {
      setHandler(false);
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-portal/use-portal.js
function portal(node, target = "body") {
  let targetNode;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetNode = document.querySelector(target);
      if (targetNode === null) {
        await tick();
        targetNode = document.querySelector(target);
      }
      if (targetNode === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetNode = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetNode.appendChild(node);
    node.hidden = false;
  }
  function destroy() {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  update(target);
  return {
    update,
    destroy
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/use-tab-leave/use-tab-leave.js
function tableave(node, callback) {
  document.addEventListener("visibilitychange", callback);
  return {
    destroy() {
      document.removeEventListener("visibilitychange", callback);
    }
  };
}

// node_modules/.pnpm/@svelteuidev+actions@0.6.3-next.4/node_modules/@svelteuidev/actions/dist/utils/clamp.js
function clamp({ value, min, max }) {
  return Math.min(Math.max(value, min), max);
}
export {
  ENVIRONMENT,
  clamp,
  clickoutside,
  clipboard,
  cssvariable,
  download,
  focus,
  getHotkeyHandler,
  hotkey,
  io,
  lazy,
  lockscroll,
  longpress,
  pageleave,
  persistenttab,
  portal,
  tableave,
  use_io_config_exports as useIoConfig
};
//# sourceMappingURL=@svelteuidev_actions.js.map
